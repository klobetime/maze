import java.util.*;

/**
 * Given a string representing a maze, generate all possible solutions.
 */
public class Maze {
    // valid characters for maze
    static final public char START = 'S';
    static final public char FINISH = 'F';
    static final public char SPACE = ' ';
    static final public char WALL = '*';
    static final public String WALL_ALT = "+-|"; // alternate chars for walls
    // character used to show a move in a solution
    static final public char MOVE = '.';
    // instance variables
    private Square start = null;
    private Square finish = null;
    private int rows;
    private int cols;
    private char[][] grid;
    private Set<List<Square>> solutions = null;
    /**
     * Construct a maze using the given string.  Walls are represented by <code>*</code>, pathways by a <code>space</code>,
     * the start square by an <code>S</code>, and the finish square by an <code>F</code>.  Rows of the maze are separated by
     * newlines.  The maze will be constructed as a rectangle, with a border added on all sides.  If rows are of different
     * lengths, walls will be added on the right to ensure all rows are the same length.
     * <p>
     * Example:
     * <pre>
     *     Maze m = new Maze(new StringBuilder()
     *         .append(" S* * \n")
     *         .append(" **    \n")
     *         .append("    ** \n")
     *         .append(" ****  \n")
     *         .append("   *F \n")
     *         .toString());
     *     System.out.println(m);
     * </pre>
     * will print
     * <pre>
     *     *********
     *     * S* * **
     *     * **    *
     *     *    ** *
     *     * ****  *
     *     *   *F **
     *     *********
     * </pre>
     * <p>
     * For input, valid characters for walls can also be <code>-|+</code>, which allows mazes as generated by
     * <a href="http://www.delorie.com/game-room/mazes/genmaze.cgi">delorie software's maze generator</a>
     *
     * @param maze A string representing the maze.
     */
    public Maze(String maze) {
        // add outside borders to maze string before processing
        String[] array = String.format("\n%s%s", maze, maze.endsWith("\n") ? "" : "\n").split("\n", -1);
        for (int i = 0; i < array.length; ++i) {
            array[i] = String.format("*%s*", array[i]);
        }

        // normalize case and find number of rows and columns
        rows = array.length;
        int longest = 0;
        for (int i = 1; i < rows; ++i) {
            array[i] = array[i].toUpperCase();
            if (array[longest].length() < array[i].length())
                longest = i;
        }
        cols = array[longest].length();

        // build grid
        grid = new char[rows][cols];
        for (int r = 0; r < rows; ++r) {
            for (int c = 0; c < cols; ++c) {
                // if the row isn't long enough, add a wall at the end
                grid[r][c] = c < array[r].length() ? array[r].charAt(c) : WALL;
                switch (grid[r][c]) {
                    case START:
                        if (null != start)
                            throw new IllegalArgumentException("only one start square allowed");
                        start = new Square(r, c);
                        break;

                    case FINISH:
                        if (null != finish)
                            throw new IllegalArgumentException("only one finish square allowed");
                        finish = new Square(r, c);
                        break;

                    case SPACE:
                    case WALL:
                        break;

                    default:
                        // make a wall if this is an alternative wall character, otherwise error out
                        if (0 > WALL_ALT.indexOf(grid[r][c]))
                            throw new IllegalArgumentException(String.format("'%c' is not a valid maze character", grid[r][c]));
                        grid[r][c] = WALL;
                }
            }
        }

        // make sure we have a start and end square
        if (null == start)
            throw new IllegalArgumentException("maze is missing start square");
        if (null == finish)
            throw new IllegalArgumentException("maze is missing finish square");
    }

    /**
     * Create a string that prints the path of the given solution.
     * <p>
     * Example:
     * <pre>
     *     Maze m = new Maze("S F\n");
     *     System.out.println(Maze.getPathString(m.solve().iterator().next()));
     * </pre>
     * will print
     * <pre>
     *     START -> [1, 1] -> [1, 2] -> [1, 3] -> FINISH
     * </pre>
     *
     * @param path A path from the start to finish of a maze.
     * @return A description of the path.
     */
    static public String getPathString(List<Maze.Square> path) {
        StringBuilder builder = new StringBuilder((2 + path.size()) * 15);
        builder.append("START -> ");
        for (Maze.Square square : path) {
            builder.append(square);
            builder.append(" -> ");
        }
        builder.append("FINISH");
        return builder.toString();
    }

    /**
     * Calculate all possible solutions to the maze.  If there are no solutions, an empty set is returned.
     *
     * @return A set of all possible solutions.
     */
    public Set<List<Square>> solve() {
        if (null == solutions) {
            Set<List<Square>> s = new HashSet<List<Square>>();
            visit(getStart(), new LinkedList<Square>(), s);
            solutions = Collections.unmodifiableSet(s);
        }
        return solutions;
    }

    public Square getStart() {
        return start;
    }

    public Square getFinish() {
        return finish;
    }

    public int getRows() {
        return rows;
    }

    public int getCols() {
        return cols;
    }

    public String drawMaze() {
        return drawMaze(false);
    }

    public String drawMaze(boolean color) {
        return drawMaze(null, color);
    }

    public String drawMaze(List<Square> solution) {
        return drawMaze(solution, false);
    }

    public String drawMaze(List<Square> solution, boolean color) {
        // set is more efficient for contains() than a list
        Set<Square> solutionSet = new HashSet<Square>();
        if (null != solution) {
            // verify all squares are from this maze
            for (Square square : solution) {
                if (square.getMaze() != this)
                    throw new IllegalArgumentException("cannot draw a solution for a different maze");
                solutionSet.add(square);
            }
        }

        int capacity = (getRows() + 1) * getCols();
        MazeStringBuilder builder = color ? new ColorMazeStringBuilder(capacity) : new MazeStringBuilder(capacity);
        for (int r = 0; r < getRows(); ++r) {
            for (int c = 0; c < getCols(); ++c) {
                char value = getGrid()[r][c];
                if (value == SPACE && solutionSet.contains(new Square(r, c)))
                    value = MOVE;
                builder.append(value);
            }
            builder.append('\n');
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (null == o || getClass() != o.getClass())
            return false;

        Maze maze = (Maze) o;
        // can't use getStart().equals(maze.getStart()) because the squares won't match because they belong to different mazes
        if (getStart().getRow() != maze.getStart().getRow())
            return false;
        if (getStart().getCol() != maze.getStart().getCol())
            return false;
        if (getFinish().getRow() != maze.getFinish().getRow())
            return false;
        if (getFinish().getCol() != maze.getFinish().getCol())
            return false;
        return Arrays.deepEquals(getGrid(), maze.getGrid());
    }

    @Override
    public int hashCode() {
        int result = Arrays.deepHashCode(getGrid());
        result = 31 * result + getStart().getRow();
        result = 31 * result + getStart().getCol();
        result = 31 * result + getFinish().getRow();
        result = 31 * result + getFinish().getCol();
        return result;
    }

    @Override
    public String toString() {
        return drawMaze();
    }

    private void visit(Square s, List<Square> path, Set<List<Square>> solutions) {
        if (isFinishSquare(s)) {
            // we have a solution; add a copy of the path to the current solution set
            path.add(s);
            solutions.add(Collections.unmodifiableList(path));
        }
        if (!path.contains(s)) {
            // we haven't visited this square in the current path, so add it and try and move in all directions
            path.add(s);
            for (Direction d : Direction.values()) {
                Square next = move(s, d);
                if (!isWallSquare(next))
                    visit(next, new LinkedList<Square>(path), solutions);
            }
        }
    }

    private Square move(Square s, Direction d) {
        int row = s.getRow();
        int col = s.getCol();
        // we don't have to watch for boundary conditions because we know there is a wall on all extreme edges
        switch (d) {
            case NORTH:
                return new Square(row - 1, col);

            case SOUTH:
                return new Square(row + 1, col);

            case EAST:
                return new Square(row, col + 1);

            case WEST:
                return new Square(row, col - 1);
        }
        // should never get here...
        throw new RuntimeException(String.format("unknown direction: %d", d));
    }

    private boolean isFinishSquare(Square s) {
        return getFinish().equals(s);
    }

    private boolean isWallSquare(Square s) {
        return WALL == getGrid()[s.getRow()][s.getCol()];
    }

    private char[][] getGrid() {
        return grid;
    }

    // possible directions to move
    private enum Direction {
        NORTH, EAST, SOUTH, WEST
    }

    /**
     * A class that represents a particular coordinate in the maze.
     */
    public class Square {
        private int row;
        private int col;

        private Square(int row, int col) {
            // verifyDimension should never fail because this is a private constructor and we are careful about the
            // parameters we pass, but belts and suspenders are a good thing at times
            this.row = verifyDimension("row", row, Maze.this.rows);
            this.col = verifyDimension("col", col, Maze.this.cols);
        }

        public int getRow() {
            return row;
        }

        public int getCol() {
            return col;
        }

        public boolean equals(int row, int col) {
            return row == getRow() && col == getCol();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (null == o || getClass() != o.getClass())
                return false;

            Square square = (Square) o;
            // squares from different mazes are not equal, even if the mazes are identical
            if (getMaze() != square.getMaze())
                return false;
            return equals(square.getRow(), square.getCol());
        }

        @Override
        public int hashCode() {
            int result = Maze.this.hashCode();
            result = 31 * result + getRow();
            result = 31 * result + getCol();
            return result;
        }

        @Override
        public String toString() {
            return String.format("[%d, %d]", getRow(), getCol());
        }

        private Maze getMaze() {
            return Maze.this;
        }

        private int verifyDimension(String desc, int x, int max) {
            if (x < 0 || x >= max)
                throw new IllegalArgumentException(String.format("%s: %d is not within [0, %d)", desc, x, max));
            return x;
        }
    }
}
